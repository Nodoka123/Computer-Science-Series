Eric Schirtzinger
May 16th, 2018

Simulated Annealing Algorithm

Introduction

	Hi, my name is Eric Schirtzinger, and this is the first, of hopefully many videos where I will demonstrate computer science related topics. While I am currently studying computer science and computer engineering at the University of Wisconsin Madison, I am no expert, so please feel free to let me know if I say something that isn’t quite right. 

Search & Optimization

	In this video, we are going to look at an optimization algorithm known as simulated annealing. To understand what this does, we need to understand what it is an optimization algorithm is attempting to solve. In optimization problems, there are many “states”, or possible solutions, and our job is to find the best one. This could be finding the shortest possible paper route for a paper boy if he must visit all homes. Or, in our example, the highest point on a hill. Each of these examples have two common elements, the states that make up the problem, order of homes to visit, or position on a hill, and the score, which would be the length of the paper route, or the height of the hill at a given location.
	For large problems, we can’t possibly hope to check all the states, it would take far too long. So instead each state has a set of neighbors or successors, which are other states that can be reached from the current state. In our example, we will start off by defining a neighbor to be the positions directly to the left and right of the current position on the hill. 

Naive hill climbing

	On first attempt at trying to solve this optimization problem, you may try to simply check the score of the left and right neighbors, if one has a higher score, move to that state, and repeat. This is known as the “hill-climbing” algorithm. If we try this on our hill, we see it works!
‘Naive_hill_climbing’ - ALGORITHM
‘600’ - POINTS_DEFAULT
‘1’ - STEP_SIZE_DEFAULT
‘1’ - KEYFRAME
‘simpleHill’ - getHill()

However, what if our hill has more than one hump? Let’s see what happens. 
‘complexHill’ - getHill()
It gets stuck! This is because when it reaches a small hilltop, known as “local maxima”, it’s neighbors are at a lower height, so we never move to those states. How do we fix this? 

Simulated Annealing
	
	We must devise a way to choose worse neighbors in hopes that we can reach the global optima. There are many ways in which we could do this, almost all involve selecting a worse neighbor with a certain probability. We will be examining the simulated annealing variation. This method is based off of the real world process of annealing, in which molten metal is slowly cooled so that it may settle in it’s most stable state. You can imagine if you had boiling hot metal and immediately cooled it down, it may have air bubbles or other inconsistencies. However, by slowly cooling it, we allow all the inconsistencies to settle down, and by the time the metal hardens it’s in its most stable state. 
Our simulation of this process is modeled in our function to determine the probability of whether or not to go to a lower state. Let’s look at the actual code. We see our probability is based on two factors, a value called ‘loss’ and a temperature. The loss is simply a measure of how much worse a neighboring state is compared to the current state. And the temperature is just that, a value to represent the current temperature. Looking at the formula we can see that our probability will go up if our loss is less. Our probability will also go up if our temperature is higher. So if we start with a very high temperature, our probability is essentially one. We will call repeated iterations to this check, but each time with a slightly lower temperature. 
Let’s see this in action. I also want to add, do to the 2-D nature of this demo, we only have 2 neighbors for each state, in order to make this to look good in this setting, I have increased the neighbors to be a couple more positions to the left and right of the current state. 
Theoretically with a very high temperature, and infinitely slow cooling rate, we will always find the global maxima. Our ball will be able to bounce all around the state space and eventually settle in at the top. 
Feel free to download the code from my Github and test out different values for Temperature and Cooling rate yourself. Please let me know what you thought of this video! Thanks for watching! 
