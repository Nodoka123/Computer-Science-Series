{"remainingRequest":"/Users/Eschirtz/Documents/02_Local_Personal/01_Code/02_Projects/01_Videos/Computer-Science-Series/node_modules/thread-loader/dist/cjs.js!/Users/Eschirtz/Documents/02_Local_Personal/01_Code/02_Projects/01_Videos/Computer-Science-Series/node_modules/babel-loader/lib/index.js!/Users/Eschirtz/Documents/02_Local_Personal/01_Code/02_Projects/01_Videos/Computer-Science-Series/node_modules/eslint-loader/index.js??ref--13-0!/Users/Eschirtz/Documents/02_Local_Personal/01_Code/02_Projects/01_Videos/Computer-Science-Series/src/views/ep01/js/algorithms.js","dependencies":[{"path":"/Users/Eschirtz/Documents/02_Local_Personal/01_Code/02_Projects/01_Videos/Computer-Science-Series/src/views/ep01/js/algorithms.js","mtime":1548279915443},{"path":"/Users/Eschirtz/Documents/02_Local_Personal/01_Code/02_Projects/01_Videos/Computer-Science-Series/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/Eschirtz/Documents/02_Local_Personal/01_Code/02_Projects/01_Videos/Computer-Science-Series/node_modules/thread-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/Eschirtz/Documents/02_Local_Personal/01_Code/02_Projects/01_Videos/Computer-Science-Series/node_modules/babel-loader/lib/index.js","mtime":1548279913642},{"path":"/Users/Eschirtz/Documents/02_Local_Personal/01_Code/02_Projects/01_Videos/Computer-Science-Series/node_modules/eslint-loader/index.js","mtime":1548279914305}],"contextDependencies":[],"result":["/**\n *  Performs one step of Simulated Annealing on the\n *  state space starting from a given state.\n *  @param state\n *  @param state_space\n *  @param temp\n *  @return s the new state\n */\nfunction simulatedAnnealing(state, stateSpace, inputTemp, stepSize) {\n  var s = state;\n  var ts = []; // Holds any worse states that were chosen\n  // Apply successor function\n\n  var successors = stateSpace.getSuccessors(state, stepSize);\n  var temp = inputTemp < 0 ? 0 : inputTemp; // For each successor\n\n  for (var i = 0; i < successors.length; i += 1) {\n    var t = successors[i]; // If score improves\n\n    if (t.score > s.score) {\n      // Always accept that successor\n      s = t;\n    } else {\n      // Accept worse state with certain probability\n      var loss = Math.abs(s.score - t.score); // Measure of how bad the state is\n\n      var probability = Math.exp(-(loss / temp)); // [ Boltzmann Distribution ]\n\n      if (Math.random() <= probability) {\n        ts.push(t); // add to potential worse neighbor list\n\n        s = t; // update new state\n      }\n    }\n  } // This is an implementation detail specific to our example\n  // we randomly select a worse neighbor, in order to prevent\n  // from always choosing the first bad neighbor in the list.\n\n\n  if (s.score < state.score) {\n    var r = Math.round(Math.random() * (ts.length - 1));\n    s = successors[r];\n  } // return the chosen state //\n\n\n  return s;\n}\n\nexport default {\n  simulatedAnnealing: simulatedAnnealing\n};",{"version":3,"sources":["/Users/Eschirtz/Documents/02_Local_Personal/01_Code/02_Projects/01_Videos/Computer-Science-Series/src/views/ep01/js/algorithms.js"],"names":["simulatedAnnealing","state","stateSpace","inputTemp","stepSize","s","ts","successors","getSuccessors","temp","i","length","t","score","loss","Math","abs","probability","exp","random","push","r","round"],"mappings":"AAAA;;;;;;;;AAQA,SAASA,kBAAT,CAA4BC,KAA5B,EAAmCC,UAAnC,EAA+CC,SAA/C,EAA0DC,QAA1D,EAAoE;AAClE,MAAIC,CAAC,GAAGJ,KAAR;AACA,MAAMK,EAAE,GAAG,EAAX,CAFkE,CAEnD;AACf;;AACA,MAAMC,UAAU,GAAGL,UAAU,CAACM,aAAX,CAAyBP,KAAzB,EAAgCG,QAAhC,CAAnB;AACA,MAAMK,IAAI,GAAGN,SAAS,GAAG,CAAZ,GAAgB,CAAhB,GAAoBA,SAAjC,CALkE,CAMlE;;AACA,OAAK,IAAIO,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,UAAU,CAACI,MAA/B,EAAuCD,CAAC,IAAI,CAA5C,EAA+C;AAC7C,QAAME,CAAC,GAAGL,UAAU,CAACG,CAAD,CAApB,CAD6C,CAE7C;;AACA,QAAIE,CAAC,CAACC,KAAF,GAAUR,CAAC,CAACQ,KAAhB,EAAuB;AACrB;AACAR,MAAAA,CAAC,GAAGO,CAAJ;AACD,KAHD,MAGO;AACL;AACA,UAAME,IAAI,GAAGC,IAAI,CAACC,GAAL,CAASX,CAAC,CAACQ,KAAF,GAAUD,CAAC,CAACC,KAArB,CAAb,CAFK,CAEqC;;AAC1C,UAAMI,WAAW,GAAGF,IAAI,CAACG,GAAL,CAAS,EAAEJ,IAAI,GAAGL,IAAT,CAAT,CAApB,CAHK,CAGyC;;AAC9C,UAAIM,IAAI,CAACI,MAAL,MAAiBF,WAArB,EAAkC;AAChCX,QAAAA,EAAE,CAACc,IAAH,CAAQR,CAAR,EADgC,CACpB;;AACZP,QAAAA,CAAC,GAAGO,CAAJ,CAFgC,CAEzB;AACR;AACF;AACF,GAtBiE,CAuBlE;AACA;AACA;;;AACA,MAAIP,CAAC,CAACQ,KAAF,GAAUZ,KAAK,CAACY,KAApB,EAA2B;AACzB,QAAMQ,CAAC,GAAGN,IAAI,CAACO,KAAL,CAAWP,IAAI,CAACI,MAAL,MAAiBb,EAAE,CAACK,MAAH,GAAY,CAA7B,CAAX,CAAV;AACAN,IAAAA,CAAC,GAAGE,UAAU,CAACc,CAAD,CAAd;AACD,GA7BiE,CA8BlE;;;AACA,SAAOhB,CAAP;AACD;;AAED,eAAe;AAAEL,EAAAA,kBAAkB,EAAlBA;AAAF,CAAf","sourcesContent":["/**\n *  Performs one step of Simulated Annealing on the\n *  state space starting from a given state.\n *  @param state\n *  @param state_space\n *  @param temp\n *  @return s the new state\n */\nfunction simulatedAnnealing(state, stateSpace, inputTemp, stepSize) {\n  let s = state;\n  const ts = []; // Holds any worse states that were chosen\n  // Apply successor function\n  const successors = stateSpace.getSuccessors(state, stepSize);\n  const temp = inputTemp < 0 ? 0 : inputTemp;\n  // For each successor\n  for (let i = 0; i < successors.length; i += 1) {\n    const t = successors[i];\n    // If score improves\n    if (t.score > s.score) {\n      // Always accept that successor\n      s = t;\n    } else {\n      // Accept worse state with certain probability\n      const loss = Math.abs(s.score - t.score); // Measure of how bad the state is\n      const probability = Math.exp(-(loss / temp)); // [ Boltzmann Distribution ]\n      if (Math.random() <= probability) {\n        ts.push(t); // add to potential worse neighbor list\n        s = t; // update new state\n      }\n    }\n  }\n  // This is an implementation detail specific to our example\n  // we randomly select a worse neighbor, in order to prevent\n  // from always choosing the first bad neighbor in the list.\n  if (s.score < state.score) {\n    const r = Math.round(Math.random() * (ts.length - 1));\n    s = successors[r];\n  }\n  // return the chosen state //\n  return s;\n}\n\nexport default { simulatedAnnealing };\n"]}]}